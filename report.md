
# 基本信息

[toc]



# 1.背景与意义

## 1.1项目开发意义

在信息化时代，数据的安全性和真实性是网络服务中至关重要的部分。从电子支付到身份认证，用户和企业都依赖于安全的通信和信任机制。本项目中，CA（Certificate Authority）机构的引入，是确保商城和银行之间可信通信的重要环节，同时也是 TLS/SSL 安全协议的基石。通过自建 CA 机构，以及银行和商城的项目开发，不仅实践了网络安全的核心技术，还模拟了真实场景下的可信生态系统建设。

### TLS/SSL 协议及 CA 机构的原理

#### 1. **TLS/SSL 协议简介**

TLS（Transport Layer Security）及其前身 SSL（Secure Sockets Layer）是现代网络通信中至关重要的安全协议，广泛用于保护诸如电子商务、在线银行业务和其他需要数据传输的场景。它们的核心目标是为网络通信提供以下三个关键特性：

- **数据加密**
   在通信过程中，TLS/SSL 使用加密技术将数据转化为不可解读的格式，防止第三方恶意窃听或截获。这种机制确保了用户隐私，即便攻击者获得了通信数据，也无法直接解密内容。
- **数据完整性**
   数据完整性通过消息认证码（MAC）技术实现，能够检测传输数据是否在途中被篡改。如果数据被修改，接收方可以立即发现，并拒绝接收这段数据。
- **身份认证**
   TLS/SSL 协议使用数字证书验证通信双方的身份，特别是服务器的身份。通过验证数字证书，客户端可以确认自己与可信的服务器建立连接，从而防止中间人攻击。

这些特性使得 TLS/SSL 成为现代互联网信任体系的重要支柱。TLS协议的位置如下图所示：

![image-20241128224339418](./images/image-20241128224339418.png)

------

#### 2. **TLS/SSL 工作流程**

TLS/SSL 协议的工作流程分为几个关键步骤，以下是详细的说明：

##### 1. **客户端发起连接**

客户端（如浏览器）向服务器发送连接请求，并表明希望建立一个 TLS/SSL 连接。这个请求通常是一个“Hello”消息，包含客户端支持的加密算法、TLS 版本及随机数。

##### 2. **服务器响应并提供证书**

服务器接收到请求后，返回其数字证书。该证书中包含：

- 服务器的公钥。
- 服务器域名。
- 证书颁发机构（CA）的签名。
- 证书的有效期。

服务器同时返回支持的加密算法列表及随机数，用于后续的密钥协商。

##### 3. **验证证书**

客户端收到服务器的证书后，会验证证书的合法性。验证包括以下几个方面：

- **签名验证：** 检查证书是否由受信任的 CA 签发。这通过客户端内置的 CA 根证书来验证签名。
- **域名匹配：** 检查证书中的域名是否与客户端请求的域名一致。
- **证书有效性：** 检查证书是否在有效期内，且未被吊销（通过 CRL 或 OCSP 查询）。

如果验证失败，客户端通常会中断连接，并向用户提示安全警告。

##### 4. **密钥协商**

一旦证书验证成功，客户端和服务器会协商生成一个对称加密密钥。这一过程使用非对称加密算法（如 RSA 或 ECDH），确保密钥在传输过程中不被泄露。密钥协商的具体方式根据协议的实现（如 TLS 1.2 和 TLS 1.3）有所不同：

- 在 TLS 1.2 中，密钥协商通过“密钥交换”算法完成。
- 在 TLS 1.3 中，密钥协商使用更高效的 Diffie-Hellman 协议，并消除了许多旧的加密方法。

##### 5. **加密通信**

一旦密钥协商完成，客户端和服务器会使用生成的对称加密密钥加密通信内容。这种对称加密（如 AES）效率更高，适合大规模数据传输。双方通信的所有内容，包括 HTTP 请求、响应头及数据，都将在加密的信道中传输。

------

### TLS/SSL 的安全性与优势

TLS/SSL 的最大优势在于它能够防范以下常见的网络攻击：

1. **中间人攻击（MITM）：** 通过身份认证，TLS/SSL 确保了通信双方的真实身份，从而有效防止中间人伪装成服务器或客户端。
2. **数据泄露：** 数据加密技术即使在攻击者截获通信内容的情况下，也能确保数据的不可解读性。
3. **篡改攻击：** 数据完整性检测机制能够识别并拒绝被篡改的数据包。

同时，TLS/SSL 的普及性和标准化使得它成为互联网信任的核心技术，应用范围涵盖 HTTPS、电子邮件传输、VPN 和在线支付等领域。

综上所述，TLS协议的交互流程如下图所示：

![image-20241128224450949](./images/image-20241128224450949.png)

------

#### 3. **CA 机构的原理**

CA（Certificate Authority）是 TLS/SSL 信任体系的核心，它是一个被广泛信任的第三方，负责颁发和管理数字证书。在 TLS/SSL 协议中，CA 通过签发数字证书，为服务器提供身份认证，从而建立起客户端对服务器的信任。

##### **CA 的主要职责**

1. **数字证书的颁发：**
    CA 根据用户（如服务器）提交的证书签名请求（CSR），验证用户身份后，使用 CA 的私钥对证书进行签名，并颁发数字证书。
2. **证书的验证：**
    客户端通过内置的 CA 根证书验证服务器证书的签名，从而确认服务器的合法性。
3. **证书的吊销管理：**
    当证书被发现不再安全（如私钥泄露）或不再可信时，CA 会将其吊销。客户端可以通过 CRL（证书吊销列表）或 OCSP（在线证书状态协议）查询证书状态。

##### **信任链机制**

CA 信任机制的核心是信任链，即：

- 客户端预安装了一组被广泛信任的根 CA 证书。
- 根 CA 可以授权下级 CA 签发证书，形成多层信任链。
- 客户端会逐级验证签名，从服务器证书追溯到根 CA，从而确认证书的可信性。

##### **自签名 CA 的局限性**

在本项目中，我们通过自建 CA 来签发和验证证书。由于我们不是可信任的证书机构，因此我们需要将自己的CA机构的签名证书导入到系统的`受信任的证书颁发机构`中，以确保后续证书链的可信度。

------

通过深入理解 TLS/SSL 协议及 CA 的工作原理，我们能够设计和实现安全可靠的通信系统，为银行和商城的开发提供强有力的技术支持。这种安全框架不仅保护了用户数据，还提升了系统的整体可信度。

### 银行和商城开发的意义

#### 1. **银行开发的意义**

银行系统的开发，是模拟现代金融系统的重要实践。它涉及到用户的身份认证、账户管理、资金转账等复杂功能，同时对安全性要求极高。

##### （1）**支付密码与邮箱验证**

支付密码和邮箱验证码是两种常见的多因素认证手段，结合在一起可以大幅提升安全性。支付密码作为静态凭证，邮箱验证码作为动态验证机制，两者结合有效防止单一凭证被攻破的风险。

##### （2）**用户资产管理**

银行系统开发的核心在于模拟用户资产管理，包括存款、取款、转账等操作。特别是在转账中，还需要验证余额是否充足、对方账户是否存在等逻辑。这种功能开发的意义在于：

- 提升对实际金融业务逻辑的理解。
- 强化编程时对事务性数据操作的处理能力，如数据一致性和回滚机制。

##### （3）**转账记录和审计**

转账历史记录的功能，不仅能提升用户体验，还能为后续的对账、审计等提供技术支持。它要求设计一个高效的查询系统，同时实现对数据的加密存储和快速读取。

#### 2. **商城开发的意义**

商城的开发，模拟了一个电子商务平台的关键模块，包括用户注册、商品购买和支付等。特别是在支付过程中，商城充当中介角色，与银行系统交互完成交易。

##### （1）**用户体验**

商城的开发注重用户体验，如用户绑定银行卡的流程、购买商品的界面设计等。用户体验的优化，是确保用户愿意长期使用平台的关键。

##### （2）**与银行系统的联动**

商城与银行系统的交互，模拟了现实中支付网关的操作。商城不直接管理用户资金，而是通过调用银行系统接口完成支付。这种设计不仅符合实际需求，还能提升系统的安全性，减少商城因资金管理失误而导致的风险。

##### （3）**跨系统通信**

通过 OAuth2 和 CA 签发的证书，商城与银行实现了安全的跨系统通信。这种通信模型在支付网关、第三方支付平台中广泛应用。

### 项目开发的综合意义

1. **网络安全实践** 通过引入 CA 机构、TLS/SSL 协议等，项目从根本上确保了通信的安全性。开发者需要深入理解 HTTPS 的工作机制，以及如何设计和实现可信的加密传输环境。
2. **现代服务架构模拟** 银行与商城分别部署在独立服务器上，并通过标准化的接口进行交互。这种分布式系统的设计，体现了现代微服务架构的核心思想。
3. **用户数据保护**
   - 银行和商城均严格遵守最小权限原则，确保用户的敏感数据（如支付密码）只在必要时使用。
   - 使用加密存储和传输技术，防止数据泄露。
4. **多角色合作开发**
   - CA 机构、银行、商城等各模块分工明确，开发中需要模拟不同角色之间的协作。这种场景贴近实际开发环境，可以帮助开发者提升团队协作能力。
5. **多因素认证的实践** 支付密码和邮箱验证码的结合，是对多因素认证的典型应用。通过这种方式，项目大大提升了系统的抗攻击能力。
6. **经济与技术双重考量** 项目不仅要求开发者理解技术细节，还需要模拟商业逻辑，如银行的资金管理、商城的商品交易等。这种跨学科的实践，能帮助开发者在技术与商业之间找到平衡点。

## 1.2 国内外现状及技术综述

#### 一、国内外金融与电商系统的现状分析

##### 1. **国际现状**

在全球范围内，金融与电商系统的融合发展已成为主流趋势。欧美发达国家的银行和电商平台在技术与服务上持续创新，为用户提供了更加安全、高效、便捷的体验。以下是主要特点：

- **线上银行化**
   国外银行系统早已实现了线上服务的普及化。例如，美国的摩根大通（JPMorgan Chase）和英国的巴克莱银行（Barclays）等均推出了功能完善的移动银行应用。这些平台不仅提供账户查询和资金转账等基本功能，还通过人工智能技术实现了理财推荐、智能客服等增值服务。
- **支付与电商深度融合**
   国外电商平台（如亚马逊和eBay）与金融支付体系紧密结合，普遍采用如PayPal和Stripe等第三方支付工具。此外，欧美国家的银行系统也在逐步介入电商支付领域，提供更低成本、更高安全性的直接支付服务。例如，Apple Pay 和 Google Pay 等技术已成为欧美用户的主流支付方式。
- **网络安全和数据隐私保护**
   随着用户对数据隐私的重视，欧美国家对金融与电商系统的网络安全提出了严格要求。例如，欧盟的《通用数据保护条例》（GDPR）对数据存储、传输和使用提出了严格规范。这推动了国外金融与电商系统在数据加密、身份认证和隐私保护方面的技术升级。

##### 2. **国内现状**

近年来，中国的银行与电商系统发展迅速，已在全球范围内占据重要地位。以支付宝和微信支付为代表的第三方支付系统成为电商支付的主力军，而传统银行也逐渐转型为以用户体验为中心的数字化服务平台。

- **支付方式的普及与创新**
   中国的支付方式已从现金和信用卡逐步转向移动支付。支付宝和微信支付通过绑定银行账户，为用户提供扫码支付、指纹支付等便捷功能。此外，央行推出的数字人民币（DCEP）成为全球首个由国家发行的法定数字货币，这标志着中国在支付技术上的全球领先地位。
- **银行系统的数字化转型**
   中国的银行正在积极进行数字化转型，以提升用户体验和运营效率。例如，工商银行、中国银行等传统银行推出了功能全面的手机银行应用，提供开户、转账、贷款申请等一站式服务。
- **金融与电商的深度合作**
   以京东金融、蚂蚁集团等为代表的国内企业，推动了电商平台与金融系统的深度融合。这些企业通过信用支付（如蚂蚁花呗、京东白条）、分期付款等金融服务，进一步增强了用户在电商平台上的消费能力。
- **网络安全与监管的强化**
   中国在网络安全方面也出台了一系列法规，例如《网络安全法》和《数据安全法》。这些法规明确了企业在用户数据保护方面的责任，同时推动了银行和电商系统在身份认证、数据加密等方面的技术创新。

------

#### 二、技术综述

##### 1. **数字证书与 CA 机构**

数字证书是现代网络安全的核心技术之一，用于验证通信双方的身份，确保数据传输的安全性。CA（证书颁发机构）作为数字证书的发行方，是互联网信任体系的基础。

- **数字证书的原理**
   数字证书包含公钥、用户信息、颁发机构和有效期等信息，并由 CA 用私钥对其进行数字签名。用户通过验证签名，可以确认证书的真实性。
- **CA 机构的作用**
   CA 机构负责颁发和管理数字证书，包括证书的签发、吊销和更新。CA 通过建立受信任的根证书，形成完整的信任链，为网络通信提供身份认证和加密支持。
- **当前发展方向**
   国外的全球性 CA（如 VeriSign 和 Let's Encrypt）已实现自动化证书颁发流程，而国内的 CA（如 CFCA）则主要服务于金融和政务领域。近年来，自建 CA 在企业内部系统中的应用逐渐增多，成为一种低成本、高可控的解决方案。

![image-20241128225825862](./images/image-20241128225825862.png)

##### 2. **TLS/SSL 加密协议**

TLS（Transport Layer Security）和 SSL（Secure Sockets Layer）是目前最广泛使用的网络加密协议，用于保护数据的机密性和完整性。

- 工作流程
  - 客户端与服务器进行握手，协商使用的加密算法。
  - 服务器提供数字证书，客户端验证其有效性。
  - 双方通过非对称加密协商出对称加密密钥，用于后续通信。
- **当前技术趋势**
   TLS 1.3 是最新版本，相较于 TLS 1.2，减少了握手过程中的明文信息传输，提升了安全性和性能。此外，HTTP/3 的发展进一步优化了基于 TLS 的网络通信效率。

##### 3. **双因子认证（2FA）**

双因子认证是增强账户安全性的重要措施，结合两种不同类型的验证方式（如密码和短信验证码），大幅降低了账户被攻破的可能性。

- 技术实现
  - 静态凭证：如支付密码。
  - 动态凭证：如邮箱验证码、短信验证码或基于时间的一次性密码（TOTP）。
- **应用场景**
   双因子认证在金融支付中广泛应用，如转账、提现等敏感操作。

![image-20241128225849539](./images/image-20241128225849539.png)

##### 4. **数据库安全与日志管理**

金融和电商系统对数据的完整性和安全性有极高要求，数据库的设计需要支持以下功能：

- 数据加密存储，防止未授权访问。
- 日志管理，记录用户行为和系统事件，为事后审计提供依据。
- 高可用性和容灾能力，确保系统在高负载和异常情况下仍能正常运行。

##### 5. **用户体验与前端框架**

用户体验是金融和电商系统成功的关键之一。现代前端框架（如 TailwindCSS）通过组件化和响应式设计，显著提升了开发效率和界面一致性。对于复杂的系统，良好的界面设计能够减少用户操作的复杂性，提高用户对系统的信任度。

------

#### 三、本项目的技术特点

本项目结合银行和商城系统开发，围绕以下几个方面展开技术创新：

1. **自建 CA 机构**
    项目引入自建 CA，为银行和商城系统之间的通信提供数字证书支持。这种机制降低了对外部 CA 的依赖，并通过吊销列表（CRL）实时管理证书的有效性。
2. **双因子认证与支付安全**
    转账操作采用支付密码和邮箱验证码的双因子认证，确保交易的合法性和安全性。
3. **TLS 加密通信**
    系统间通信使用基于 TLS 的加密协议，并结合 CA 验证，防止中间人攻击和数据泄露。
4. **转账记录的实时查询**
    银行用户可以通过专门的界面查看历史交易记录，便于资金流向追踪和账单核对。
5. **支付与商城系统集成**
    商城系统通过与银行系统对接，实现支付功能的无缝整合，提升了电商平台的用户体验和安全性。

------

### 总结

国内外金融和电商系统的快速发展，为本项目提供了广阔的技术背景。通过引入 CA 机构、TLS 加密协议和双因子认证，本项目不仅实现了银行和商城系统的安全通信，还在用户体验和数据安全方面实现了创新性突破。这种技术架构具有高度的实用性和可扩展性，为类似项目的开发提供了有益借鉴。

### 我做的基本工作

在本次实践课中，我实现了一套完整的银行系统，用户可以进行注册、申请银行卡、充值、转账，并且实现了简单的交易和转账记录。同时实现了一套完整的线上商城，模拟场景是对应的二手商城交易平台，用户可以注册、登录自己的账户，可以自己上传需要卖出的商品，同时实现了完整的购物车系统以及结算系统。

在银行和商城的交互过程中，我在银行侧实现了一个`Oauth2.0`的协议，便于商城进行银行绑定，同时实现了银行的一个支付接口，商城只需要满足对应的接口条件，就可以使用银行作为支付凭证。

项目仓库如下图

![6f8f869ccd914f4946720e18f5ab695](./images/6f8f869ccd914f4946720e18f5ab695.png)

代码的架构以及代码量分析如下图

![69f7566bdc537f6cdc8728d3ebf893c](./images/69f7566bdc537f6cdc8728d3ebf893c.png)

### 项目的一些必要妥协

CA机构需要是系统和浏览器信任的机构，但是项目中CA是自签名的，因此需要手动添加到信任的证书环境中，尽管如此，依然会发生浏览器将网页识别为`不安全`的情况，但实际上`tls1.2`协议已经正常工作，且证书可以被有效验证，因此不影响最终的安全性。

我将项目的重点放置在开发的过程中尽可能保持环境的安全性、鲁邦性上，因此只实现了必要的功能，其余的功能可以在已有的架构上简单扩展，例如实现`购物车移除商品`等。

# 2. 需求分析

## 2.1 总体需求

本项目旨在开发一个集成了 **银行系统**、**CA（证书颁发机构）系统** 和 **商城系统** 的多功能平台，重点解决跨系统之间的安全通信和用户交易体验问题。通过引入 CA 机构，保障系统之间的身份认证和数据加密，同时提升银行和商城在支付和交易方面的安全性、可靠性和用户体验。项目的难点在于设计好三个模块之间的api并调通他们之间的信息交互。

**总体需求目标**：

1. **安全性**：通过 TLS 加密和自建 CA 机构，确保系统间通信和用户数据传输的安全性。
2. **可靠性**：实现用户账户管理、交易记录存储和支付功能的高效运行。
3. **扩展性**：为未来系统的功能扩展和第三方对接提供灵活的接口和安全保障。
4. **易用性**：提供直观的用户界面和流畅的用户操作体验，降低系统使用门槛。
5. **性能要求**：项目应该具有一定的高性能，可以应对一定的并发请求情况。

项目使用的技术栈

| 名称       | 用途                         | 备注                                                         |
| ---------- | ---------------------------- | ------------------------------------------------------------ |
| python     | 后端                         |                                                              |
| Flask      | 后端主要模块                 |                                                              |
| WTForms    | 用于处理前端提交表格的中间件 | 集成在视图函数业务逻辑中                                     |
| Werkzeug   | Flask集成好的主要的安全模块  |                                                              |
| SQLAlchemy | ORM中间件                    | 重写了Base类，在提交失败的时候数据库自动回滚，增强代码可读性 |
| Crypto     | 加密库                       | 主要服务在证书机构和银行的一些数据加密函数中                 |
| MySQL      | 数据库                       |                                                              |
| Jinja      | 与Flask配对好的前端渲染模板  | 样式使用TailWindCSS编写，利用nodejs编译好css，默认主题       |
| Git        | 版本管理                     |                                                              |



## 2.2 功能需求

### 2.2.1 银行

**用户管理**：

- 用户注册、登录和激活功能。
- 支持用户信息（如昵称、邮箱、支付密码）的管理与修改。
- 提供多因素验证（支付密码 + 验证码）以增强账户安全。

**银行卡管理**：

- 用户可申请新银行卡，卡号自动生成。
- 通过验证码激活银行卡，激活后可进行充值、转账等操作。
- 支持银行卡余额查询、充值和提现功能。

**支付功能**：

- 实现用户间的转账功能，用户输入付款卡号和收款卡号可以进行转账，系统应该自行能够判断卡号存在性并检查余额。
- 支持与商城系统对接，提供购买支付功能。
- 支持交易失败回滚机制，确保资金的完整性。

**交易记录管理**：

- 用户可查看个人的转账和进账记录。
- 交易记录包含日期、交易对方、金额、交易类型（进账/出账）等详细信息。
- 支持按时间和类型筛选记录。

### 2.2.2 CA（证书颁发机构）系统

CA 机构为项目提供信任基础，用于银行和商城系统之间的身份认证和数据加密。

**证书颁发**：

- CA 机构接受银行或商城的注册请求，为其颁发数字证书。
- 数字证书包括机构名称、公钥、有效期等信息，并由 CA 私钥签名。

**证书管理**：

- 支持证书的吊销和更新功能。
- 提供证书吊销列表（CRL），供其他系统查询证书有效性。

**证书验证**：

- 提供 API 接口供银行和商城查询证书是否被吊销。
- 验证证书的合法性，包括签名校验和有效期检查。

**日志管理**：

- 记录证书的申请、签发、吊销等操作，供系统管理员审计。

### 2.2.3商城系统

**用户管理**：

- 用户注册、登录和账户管理。
- 支持商城账户绑定银行账户，方便支付和提现操作。

**商品管理**：

- 商城管理员可添加、修改和删除商品信息。
- 用户可浏览商品列表，查看商品详情。

**购物车与订单管理**：

- 提供购物车功能，用户可选择商品并提交订单。
- 支持订单状态管理（如待支付、已支付、已取消）。
- 提供用户订单历史查询功能。

**支付功能**：

- 通过对接银行系统，完成订单的支付。
- 支持退款功能，确保订单取消后资金退回原账户。

**通知与反馈**：

- 支持订单和支付状态的实时通知。
- 提供用户对商品和商城服务的反馈功能。

## 2.3 性能需求

CA机构不需要特别高的性能，因为主要是在两个模块之间通信和最初签发证书时进行运算操作，由于项目中使用的是非对称密码系统，而且主要是RSA系统（比对称密钥系统慢上千数量级），因此响应速度只需要在毫秒级即可。

且CA机构使用的是安全隧道，要验证服务器证书的有效性，同时要查询数据库中证书是否被吊销，故性能要求也应当是100ms的数量级。

而银行系统会存在大量用户申请接口的问题，且绝大多数接口都需要频繁查询数据库服务器，考虑到后端与数据库服务器建立连接的过程是`tcp`连接，且每次查询完毕后`tcp`连接都会断开，因此需要建立`数据库连接池`来提高查询效率，且系统应该能够承载住并发场景。

商城场景应当考虑到高负载的情况，例如当用户上传了一个抢手的商品，可能会瞬间收到大量的请求轰炸，同时商城和银行之间的Order信息有较长的消息流通路径，应当使用`redis`来缓存消息队列。

# 3. 概要设计

整个系统可以范围三个大的模块`银行系统`，`商城系统`，`证书机构`。

## 3.1 证书CA机构

证书机构负责管理证书，包括对证书的分发、验证、以及吊销。应当提供详细的接口来便于银行系统和商城系统申请证书，并验证对方的证书以确保可信，在拥有证书后，银行系统和商城系统之间的通信可以通过证书来建立安全的 TLS 通道，从而保证数据的安全传输。

### 3.1.1 功能设计

1. **证书申请接口**
   - 提供 RESTful API，供银行和商城系统申请证书。
   - 接收客户端的申请信息（如系统名称、公共密钥等），验证后生成证书并返回。
2. **证书验证接口**
   - 提供证书验证功能，验证客户端的证书是否合法、是否被吊销。
   - 支持证书的链式验证，通过 CA 根证书校验子证书的合法性。
3. **证书吊销管理**
   - 实现证书吊销接口，允许管理员吊销不再信任的证书。
   - 提供 CRL（证书吊销列表）供系统查询，确保吊销后的证书不能再被使用。
4. **日志审计功能**
   - 记录证书的颁发、验证、吊销等操作日志，方便系统管理员进行安全审计。
   - 日志内容包括操作时间、操作类型、证书信息等。

### 3.1.2 交互设计

- 银行和商城系统首次通信时，通过 CA 机构获取证书，建立相互信任的安全通信链路。
- 在后续的每次通信中，银行和商城系统通过 CA 提供的接口验证对方证书的合法性。
- CA 系统在检测到证书被吊销或异常使用时，向相关系统发出警告并中断不安全的通信。

## 3.2 银行系统

银行系统是整个项目的核心模块，负责管理用户账户、支付交易和转账记录，是用户资金管理的主要入口。

### 3.2.1 功能设计

1. **用户管理**
   - 用户注册：支持用户通过邮箱注册账户。
   - 用户登录：通过密码和验证码双重验证，确保登录安全。
   - 账户信息管理：支持用户修改个人信息、支付密码等。
2. **银行卡管理**
   - 申请银行卡：用户提交申请后自动生成卡号，进行激活验证。
   - 激活银行卡：通过邮箱验证码激活银行卡后，才能进行交易。
   - 余额查询：实时显示银行卡余额，并提供余额掩码功能。
3. **支付与转账功能**
   - 转账功能：支持用户之间的资金转账，要求输入支付密码并验证邮箱验证码。
   - 商城支付：与商城系统对接，实现订单支付。
   - 支持交易失败回滚机制，确保资金安全。
4. **交易记录管理**
   - 支持用户查看转账记录和进账记录。
   - 记录详细信息，包括交易时间、交易对象、交易金额等。
5. **安全功能**
   - 双因子认证：支付密码和验证码结合，防止未经授权的支付。
   - TLS 加密通信：通过证书验证对方身份，确保通信安全。

### 3.2.2 交互设计

- 用户通过银行系统管理账户和银行卡，进行安全的资金操作。
- 每次支付操作，银行系统会请求 CA 验证商城系统的证书，确保对方合法。
- 用户在商城完成支付后，银行系统记录相关交易信息，便于用户查询。

## 3.3 商城系统

商城系统主要为用户提供商品购买、支付和订单管理功能，是银行支付功能的重要使用场景。

### 3.3.1 功能设计

1. **用户管理**
   - 用户注册：支持用户注册商城账户。
   - 用户登录：通过邮箱和密码登录。
   - 账户绑定：支持用户将商城账户绑定银行账户，便于支付操作。
2. **商品管理**
   - 支持商城管理员添加、修改、删除商品信息。
   - 商品分类管理，用户可以根据分类快速浏览商品。
3. **购物车与订单管理**
   - 用户可以将商品加入购物车，并提交订单。
   - 订单状态管理：包括待支付、已支付、已取消等。
4. **支付功能**
   - 与银行系统对接，实现订单支付。
   - 支持订单退款，确保用户在订单取消后可以退回资金。
5. **订单与支付记录管理**
   - 用户可查看历史订单和支付记录。
   - 支持按照时间和状态筛选订单。

### 3.3.2 交互设计

- 用户在商城系统中选择商品并提交订单后，系统通过 TLS 通道向银行发起支付请求。
- 商城系统验证银行系统的证书合法性后，完成支付操作并更新订单状态。
- 支付完成后，商城系统将订单状态通知用户，并记录支付明细。

### 项目整体交互设计

1. **首次通信**
   - 银行系统和商城系统首次通信时，通过 CA 获取证书并建立信任关系。
2. **支付流程**
   - 用户在商城提交订单后，商城向银行发起支付请求。
   - 银行验证商城证书并通过双因子认证完成支付。
   - 支付完成后，商城更新订单状态并通知用户。
3. **系统安全保障**
   - 所有系统间通信均使用 TLS 加密，防止数据泄露。
   - 通过 CA 实现动态证书验证，确保通信双方合法。

项目的三大模块总体信息流程如下

![总体设计图.drawio](./images/总体设计图.drawio-1732808038090-6.png)

# 4. 详细设计

## 4.1 CA机构

#### 后端API与数据库设计

CA机构维护了一张表，如下图所示

![image-20241128234053111](./images/image-20241128234053111.png)

其中`id`是主键，`common_name`是申请证书机构的名称，例如银行申请的证书为`bank_application`，`certificate_pem`是证书，而`private_key`则是用于签名的私钥。`issue_date`是证书颁发的日期，`expiry_date`是证书过期日期，通过严格限定证书的颁发日期和过期日期，并确定唯一编号，可以防止重放攻击。`revoked`字段是证书是否过期的标志。

### CA机构的API

| 组件           | 操作类型 | 描述                                                         |
| -------------- | -------- | ------------------------------------------------------------ |
| **Web 服务器** | GET      | 处理首页请求，显示主页 (`index` 路由)                        |
| **Web 服务器** | GET      | 处理证书查看请求，显示所有证书 (`certificates` 路由)         |
| **Web 服务器** | GET/POST | 处理证书颁发请求，提供证书和私钥生成与下载 (`issue_certificate` 路由) |
| **Web 服务器** | POST     | 处理证书撤销请求，通过证书 ID 撤销证书 (`revoke_certificate` 路由) |
| **Web 服务器** | POST     | 处理 API 请求，颁发新证书并返回证书和私钥 (`api_issue_certificate` 路由) |
| **Web 服务器** | POST     | 处理 API 请求，验证证书是否被吊销 (`api_verify_certificate` 路由) |

### API的处理流程

1. **证书颁发**

![image-20241128234623052](./images/image-20241128234623052.png)

- 客户端发送 POST 请求到 `/api/issue_certificate`，包含 `common_name` 参数。
- 服务器检查数据库中是否已有有效证书。如果存在且未吊销，返回证书和私钥给客户端。
- 如果证书已过期或吊销，服务器生成新的证书，保存到数据库，并返回给客户端。

2. **验证证书流程**

![image-20241128234656667](./images/image-20241128234656667.png)

* 客户端发送 POST 请求到 `/api/verify_certificate`，包含 `common_name` 参数。

* 服务器调用证书管理模块检查证书是否被吊销，并返回吊销状态给客户端。

3. **证书颁发视图**

![image-20241128234724740](./images/image-20241128234724740.png)

* 用户提交表单，包含 `common_name`。

* 服务器检查数据库中是否已有该证书。如果已存在，返回证书列表页面。

* 如果没有证书，服务器生成新证书并返回给客户端显示。

4. **证书撤销视图函数**

![image-20241128234759753](./images/image-20241128234759753.png)

* 客户端发起撤销证书的请求，服务器根据证书 ID 查询数据库。

* 如果证书存在，服务器调用证书管理模块撤销证书，并重定向回证书列表页面。

#### 前端界面设计

利用`Flask-Jinja`来做模板渲染，设置了一个主页、证书管理界面和证书颁发界面

![image-20241203154156492](./images/image-20241203154156492.png)

![image-20241203154201176](./images/image-20241203154201176.png)

![image-20241203154206205](./images/image-20241203154206205.png)

### 4.2银行

#### 后端API及数据库设计

![image-20241203154435267](./images/image-20241203154435267.png)

### **1. bank_user 表**

#### **表说明**

`bank_user` 表用于存储银行系统的用户信息，每个用户在银行系统中必须有一个唯一的标识 `UserId`，并且用户可以通过邮箱注册，且支持验证密码和支付密码。此外，用户还可以有多个银行卡和交易记录。

#### **字段说明**

| 字段名称           | 说明                                                        |
| ------------------ | ----------------------------------------------------------- |
| **UserId**         | 用户的唯一标识，主键，自增。                                |
| **nickname**       | 用户昵称，用于用户展示，非空。                              |
| **email**          | 用户的邮箱地址，用于登录和找回密码，唯一，非空。            |
| **_password**      | 用户密码的哈希值，非空。                                    |
| **isExamined**     | 标识用户是否经过审核，默认值为 `False`。                    |
| **_payPassword**   | 用户的支付密码的哈希值，非空。                              |
| **isAdmin**        | 用户是否为管理员，`True` 表示管理员，`False` 表示普通用户。 |
| **IdCardNumber**   | 用户的身份证号，非必填。                                    |
| **_captcha**       | 存储用户的验证码的哈希值。                                  |
| **captcha_expiry** | 存储验证码的过期时间，防止过期验证码的滥用。                |

------

### **2. bank_card 表**

#### **表说明**

`bank_card` 表用于存储用户的银行卡信息，每张银行卡与一个用户关联，并存储其余额和状态等信息。银行卡卡号是唯一的，用于用户在银行系统中的标识。

#### **字段说明**

| 字段名称        | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| **CardId**      | 银行卡的唯一标识，主键，自增。                               |
| **card_number** | 银行卡号，唯一，长度为19位，非空。                           |
| **balance**     | 银行卡余额，默认值为 0.0，存储浮动金额。                     |
| **is_active**   | 银行卡是否有效，默认为 `False`，表示卡片是否启用。           |
| **_captcha**    | 用于存储银行卡操作时的验证码的哈希值。                       |
| **user_id**     | 外键，关联到 `bank_user` 表的 `UserId`，表示这张银行卡属于哪个用户。 |

------

### **3. oauth_client 表**

#### **表说明**

`oauth_client` 表用于存储 OAuth 客户端的相关信息，包含客户端的标识和密钥、授权的重定向 URI 列表以及是否为机密客户端等信息。每个客户端通过 `client_id` 和 `client_secret` 唯一标识。

#### **字段说明**

| 字段名称            | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| **client_id**       | OAuth 客户端的唯一标识符，主键。                             |
| **client_secret**   | OAuth 客户端的密钥，用于客户端验证身份，非空。               |
| **redirect_uris**   | 逗号分隔的 URI 列表，用于存储重定向 URI，多个 URI 之间用逗号分隔。 |
| **is_confidential** | 是否为机密客户端，默认值为 `True`，表示客户端是否保密。      |
| **client_name**     | 客户端的名称，用于标识客户端。                               |

------

### **4. oauth_grant 表**

#### **表说明**

`oauth_grant` 表用于存储授权码信息，是 OAuth2 授权流程的一部分。它记录了用户在 OAuth 客户端中授权的相关信息，包括授权码、过期时间和作用域。

#### **字段说明**

| 字段名称         | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| **id**           | 授权码的唯一标识，主键，自增。                               |
| **user_id**      | 外键，关联到 `bank_user` 表的 `UserId`，表示该授权码属于哪个用户。 |
| **client_id**    | 外键，关联到 `oauth_client` 表的 `client_id`，表示授权码属于哪个客户端。 |
| **code**         | 授权码，唯一，非空，用于 OAuth2 授权流程。                   |
| **redirect_uri** | 客户端请求时使用的重定向 URI。                               |
| **expires**      | 授权码的过期时间，默认值为当前时间加上 10 分钟。             |
| **scopes**       | 作用域，表示授权码所授予的权限范围。                         |

------

### **5. oauth_token 表**

#### **表说明**

`oauth_token` 表用于存储 OAuth 访问令牌信息，包括访问令牌和刷新令牌等。该表记录了用户与客户端的授权关系，并指定了令牌的过期时间。

#### **字段说明**

| 字段名称          | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| **id**            | 令牌的唯一标识，主键，自增。                                 |
| **client_id**     | 外键，关联到 `oauth_client` 表的 `client_id`，表示令牌属于哪个客户端。 |
| **user_id**       | 外键，关联到 `bank_user` 表的 `UserId`，表示令牌属于哪个用户。 |
| **access_token**  | 唯一的访问令牌，用于用户授权的身份验证，非空。               |
| **refresh_token** | 唯一的刷新令牌，用于刷新访问令牌，非空。                     |
| **expires**       | 令牌的过期时间，默认值为当前时间加上 1 小时。                |
| **scopes**        | 作用域，表示访问令牌所授予的权限范围。                       |
| **revoked**       | 标识令牌是否已被撤销，默认值为 `False`。                     |

------

### **6. payment_cache 表**

#### **表说明**

`payment_cache` 表用于缓存支付相关的订单信息。它记录了买方的用户 ID、卖方的支付信息、总金额、订单 ID 以及过期时间，用于支持支付过程中的事务管理。

#### **字段说明**

| 字段名称               | 说明                                                |
| ---------------------- | --------------------------------------------------- |
| **payment_id**         | 支付记录的唯一标识，主键。                          |
| **buyer_bank_user_id** | 买方的用户 ID，关联到 `bank_user` 表。              |
| **seller_payments**    | 卖方支付的相关信息，存储为 JSON 格式。              |
| **total_amount**       | 总金额，表示此次支付的总额。                        |
| **order_ids**          | 订单 ID 列表，存储为 JSON 格式，包含多个订单的 ID。 |
| **expires_at**         | 支付记录的过期时间，支付超时后该记录失效。          |

------

### **7. transactions 表**

#### **表说明**

`transactions` 表用于记录银行用户之间的交易信息。每笔交易包含发送方和接收方的用户信息、交易金额、交易类型、状态以及时间戳等信息。

#### **字段说明**

| 字段名称             | 说明                                                       |
| -------------------- | ---------------------------------------------------------- |
| **id**               | 交易的唯一标识，主键，自增。                               |
| **sender_id**        | 外键，关联到 `bank_user` 表的 `UserId`，表示交易的发送方。 |
| **recipient_id**     | 外键，关联到 `bank_user` 表的 `UserId`，表示交易的接收方。 |
| **amount**           | 交易金额，表示交易的金额。                                 |
| **transaction_type** | 交易类型，可以是 `TRANSFER`（转账）或 `PAYMENT`（支付）。  |
| **status**           | 交易状态，表示交易是否成功，`SUCCESS` 或 `FAILED`。        |
| **timestamp**        | 交易的时间戳，记录交易发生的时间。                         |

#### 后端API实现

#### Auth 模块 - 接口流程与说明

**1. `/bank/register` - 用户注册**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务端
    U->>S: 提交注册表单 (nickname, email, password, payPassword)
    S->>S: 验证字段是否完整
    S->>S: 验证邮箱格式
    S->>S: 检查邮箱是否已注册
    S->>S: 存储用户信息
    S->>U: 返回注册成功消息
```

**接口功能与流程：**

- 用户提交昵称、邮箱、密码、支付密码进行注册。
- 服务端验证输入信息是否完整，邮箱格式是否合法，且该邮箱是否已注册。
- 如果验证通过，创建用户并保存到数据库，最终返回成功注册消息并跳转到登录页面。

------

**2. `/bank/login` - 用户登录**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务端
    U->>S: 提交登录表单 (email, password, remember)
    S->>S: 验证字段是否完整
    S->>S: 验证邮箱格式
    S->>S: 检查用户是否存在
    S->>S: 验证密码
    S->>S: 生成JWT令牌
    S->>U: 返回登录成功消息和JWT令牌
```

**接口功能与流程：**

- 用户输入邮箱和密码进行登录。
- 服务端验证邮箱格式，检查用户是否存在以及密码是否正确。
- 如果验证通过，生成JWT令牌并返回，成功登录后跳转到用户的个人仪表盘。

------

**3. `/bank/activate` - 账户激活请求**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务端
    U->>S: 提交激活请求
    S->>S: 检查用户是否已激活
    S->>S: 生成验证码并发送邮件
    S->>U: 返回激活邮件已发送消息
```

**接口功能与流程：**

- 用户发起账户激活请求。
- 服务端检查账户是否已经激活，若未激活，生成验证码并发送到用户邮箱。
- 返回激活邮件已发送的提示。

------

**4. `/bank/activate/confirm` - 确认账户激活**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务端
    U->>S: 提交验证码
    S->>S: 验证验证码是否有效
    S->>S: 激活账户
    S->>U: 返回账户激活成功消息
```

**接口功能与流程：**

- 用户提交从邮件中收到的验证码。
- 服务端验证验证码的有效性，若通过，激活用户账户。
- 返回账户激活成功的提示。

------

**5. `/bank/reset/password` - 重置密码请求**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务端
    U->>S: 提交重置密码请求 (email)
    S->>S: 检查邮箱格式
    S->>S: 检查用户是否存在
    S->>S: 生成验证码并发送邮件
    S->>U: 返回重置密码验证码已发送消息
```

**接口功能与流程：**

- 用户提供邮箱地址请求重置密码。
- 服务端验证邮箱格式并检查用户是否存在。
- 生成验证码并通过邮件发送给用户，提示用户进行下一步操作。

------

**6. `/bank/reset/password/confirm` - 确认重置密码**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务端
    U->>S: 提交新密码、验证码
    S->>S: 验证验证码是否有效
    S->>S: 更新用户密码
    S->>U: 返回密码重置成功消息
```

**接口功能与流程：**

- 用户提供验证码及新密码。
- 服务端验证验证码并更新用户密码。
- 如果验证通过，返回密码重置成功消息。

------

**7. `/bank/logout` - 用户退出登录**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务端
    U->>S: 发起退出请求
    S->>S: 清除用户会话和令牌
    S->>U: 返回退出成功消息
```

**接口功能与流程：**

- 用户发起退出登录请求。
- 服务端清除JWT令牌及相关会话信息。
- 返回退出成功的消息并跳转到登录页面。

------

**8. `/set_paypassword` - 设置支付密码请求**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务端
    U->>S: 提交支付密码设置表单 (payPassword)
    S->>S: 验证支付密码格式
    S->>S: 生成验证码并发送邮件
    S->>U: 返回验证码已发送消息
```

**接口功能与流程：**

- 用户提交支付密码设置请求。
- 服务端验证支付密码的格式是否符合要求。
- 如果格式正确，生成验证码并发送到用户邮箱，提示用户进行确认。

------

**9. `/confirm_paypassword` - 确认支付密码设置**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务端
    U->>S: 提交验证码
    S->>S: 验证验证码是否有效
    S->>S: 设置支付密码
    S->>U: 返回支付密码设置成功消息
```

**接口功能与流程：**

- 用户提供验证码并确认支付密码。
- 服务端验证验证码并成功设置支付密码。
- 返回支付密码设置成功消息。

------

#### 银行核心业务逻辑

### 1. **申请银行卡 (apply_bank_card)**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务器
    participant DB as 数据库
    participant E as 邮件服务

    U->>S: 提交银行卡申请请求
    S->>DB: 查找用户是否激活
    DB->>S: 返回用户信息
    S->>DB: 创建新的银行卡记录
    DB->>S: 返回银行卡ID
    S->>E: 发送验证码至用户邮箱
    E->>U: 邮件发送成功
    S->>U: 返回银行卡激活页面
```

**接口功能与流程：**

- 用户提交银行卡申请请求。
- 系统验证用户是否已经激活（通过`isExamined`字段）。
- 若用户已激活，系统创建银行卡记录并保存至数据库。
- 系统发送绑定银行卡的验证码到用户邮箱。
- 用户获取验证码后，进入银行卡确认页面。

### 2. **确认银行卡 (confirm_bank_card)**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务器
    participant DB as 数据库
    participant E as 邮件服务

    U->>S: 提交银行卡确认请求
    S->>DB: 解密银行卡信息
    DB->>S: 返回银行卡信息
    S->>E: 发送验证码至用户邮箱
    E->>U: 邮件发送成功
    U->>S: 提交验证码
    S->>DB: 验证验证码
    DB->>S: 验证结果
    S->>DB: 激活银行卡
    DB->>S: 返回激活结果
    S->>U: 返回银行卡激活成功页面
```

**接口功能与流程：**

- 系统解密银行卡信息并验证用户身份。
- 系统发送验证码至用户邮箱。
- 用户提交验证码，系统验证验证码是否正确。
- 验证通过后，激活银行卡。

### 3. **充值 (deposit)**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务器
    participant DB as 数据库
    participant E as 邮件服务

    U->>S: 提交充值请求
    S->>DB: 获取银行卡信息
    DB->>S: 返回银行卡信息
    S->>E: 发送验证码至用户邮箱
    E->>U: 邮件发送成功
    U->>S: 提交充值验证码
    S->>DB: 验证验证码
    DB->>S: 验证结果
    S->>DB: 更新银行卡余额
    DB->>S: 返回余额更新结果
    S->>U: 返回充值成功页面
```

**接口功能与流程：**

- 用户提交充值金额，系统检查金额是否合法。
- 系统查询用户银行卡信息并发送充值验证码至用户邮箱。
- 用户输入验证码，系统验证验证码有效性。
- 验证通过后，系统更新银行卡余额，完成充值。

### 4. **取款 (withdraw)**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务器
    participant DB as 数据库

    U->>S: 提交取款请求
    S->>DB: 获取银行卡信息
    DB->>S: 返回银行卡信息
    S->>DB: 验证余额是否足够
    DB->>S: 余额验证结果
    S->>DB: 执行取款操作
    DB->>S: 返回取款结果
    S->>U: 返回取款结果页面
```

**接口功能与流程：**

- 用户提交取款请求，输入金额和银行卡信息。
- 系统验证银行卡余额是否足够。
- 验证通过后，执行取款操作并更新余额。

### 5. **转账 (transfer)**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务器
    participant DB as 数据库
    participant E as 邮件服务

    U->>S: 提交转账请求
    S->>DB: 查询转出银行卡信息
    DB->>S: 返回转出银行卡信息
    S->>DB: 查询收款银行卡信息
    DB->>S: 返回收款银行卡信息
    S->>E: 发送转账验证码至用户邮箱
    E->>U: 邮件发送成功
    U->>S: 提交转账验证码
    S->>DB: 验证验证码
    DB->>S: 验证结果
    S->>DB: 执行转账操作
    DB->>S: 更新银行卡余额
    S->>U: 返回转账成功页面
```

**接口功能与流程：**

- 用户提交转账请求，系统查询转出银行卡和收款银行卡信息。
- 系统验证余额是否充足，发送转账验证码至用户邮箱。
- 用户输入验证码，验证成功后执行转账操作。

### 6. **查询交易历史 (transaction_history)**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务器
    participant DB as 数据库

    U->>S: 提交查询交易历史请求
    S->>DB: 查询交易历史
    DB->>S: 返回交易历史
    S->>U: 返回交易历史页面
```

**接口功能与流程：**

- 用户提交查询交易历史请求。
- 系统从数据库查询该用户的所有交易记录并返回。

### 7. **创建支付 (create_payment)**

```mermaid
sequenceDiagram
    participant U as 用户
    participant S as 服务器
    participant DB as 数据库

    U->>S: 提交创建支付请求
    S->>DB: 存储支付信息
    DB->>S: 返回支付ID
    S->>U: 返回支付ID
```

**接口功能与流程：**

- 用户提交支付请求，系统生成唯一支付ID。
- 系统将支付信息存储在数据库中并返回支付ID。

------

### 前端界面设计

前端采用TailWindCss提供样式模板，然后通过编写`base.html`来规范基本格式，比如导航栏、Flask的消息闪现`Flash`的样式，以及中间的主题内容分。

用户首先会被引导到登录界面

![image-20241203160319049](./images/image-20241203160319049.png)

如果没有账号，可以申请注册

![image-20241203160331391](./images/image-20241203160331391.png)

主界面

![image-20241203160348648](./images/image-20241203160348648.png)

同时设计了银行卡号的敏感信息保护选项 确保截图分享时信息的安全

![image-20241203160409807](./images/image-20241203160409807.png)

转账界面，用户可以输入自己的付款卡和收款人卡号，然后点击`发送验证码`就可以获得转账的确认验证

![image-20241203160501261](./images/image-20241203160501261.png)

用户可以在交易历史中查询自己的交易记录

![image-20241203160524196](./images/image-20241203160524196.png)

也可以申请一张新的银行卡

![image-20241203160536980](./images/image-20241203160536980.png)

![image-20241203160544047](./images/image-20241203160544047.png)

同时为了美观，对邮箱的格式也做了样式渲染

![image-20241203160615748](./images/image-20241203160615748.png)

消息闪现的样式，`info`是绿色，`error`是红色

![image-20241203160639014](./images/image-20241203160639014.png)

### 商城模块

#### 后端API以及数据库设计

![image-20241203160848421](./images/image-20241203160848421.png)

### **表格描述**

1. **`cart_item`（购物车条目表）**
   - 记录用户购物车中商品的信息。
2. **`item`（商品表）**
   - 存储商品的详细信息，包括名称、类型、价格等。
3. **`order`（订单表）**
   - 记录订单相关信息，包括订单号、买卖双方、商品详情等。
4. **`shop_user`（用户表）**
   - 存储商城用户的信息，包括用户名、邮箱、密码等。

------

### **字段详细描述**

#### 1. `cart_item` 表

| 字段名     | 类型    | 描述                                                         |
| ---------- | ------- | ------------------------------------------------------------ |
| `id`       | Integer | 主键，唯一标识购物车条目。                                   |
| `user_id`  | Integer | 外键，关联到 `shop_user` 表中的 `UserId`，表示该条目属于哪个用户。 |
| `item_id`  | Integer | 外键，关联到 `item` 表中的 `ItemId`，表示购物车中的商品。    |
| `quantity` | Integer | 表示购物车中该商品的数量，默认为 1。                         |

**功能描述：**

- `cart_item` 表用于存储用户的购物车信息，记录每个用户所选择的商品及其数量。

------

#### 2. `item` 表

| 字段名        | 类型    | 描述                                                         |
| ------------- | ------- | ------------------------------------------------------------ |
| `ItemId`      | Integer | 主键，唯一标识商品。                                         |
| `Item_name`   | String  | 商品名称，最大长度 50 字符。                                 |
| `Item_type`   | String  | 商品类别，最大长度 50 字符。                                 |
| `is_approved` | Boolean | 商品是否通过审核，默认值为 `False`。                         |
| `is_open`     | Boolean | 商品是否开放销售，默认值为 `False`。                         |
| `description` | String  | 商品描述，最大长度 256 字符。                                |
| `image_path`  | String  | 商品图片的存储路径，最大长度 256 字符。                      |
| `price`       | Float   | 商品价格，不允许为空。                                       |
| `owner_id`    | Integer | 外键，关联到 `shop_user` 表中的 `UserId`，表示商品的所属用户。 |

**功能描述：**

- `item` 表用于存储商品信息，包含商品的基础信息如名称、类别、价格等，以及图片路径等资源链接。
- 通过 `owner_id` 关联到用户表，标识商品的拥有者。

------

#### 3. `order` 表

| 字段名         | 类型     | 描述                                                         |
| -------------- | -------- | ------------------------------------------------------------ |
| `OrderId`      | Integer  | 主键，唯一标识订单。                                         |
| `order_number` | String   | 订单编号，最大长度 50 字符，唯一约束。                       |
| `buyer_id`     | Integer  | 外键，关联到 `shop_user` 表中的 `UserId`，表示买家。         |
| `seller_id`    | Integer  | 外键，关联到 `shop_user` 表中的 `UserId`，表示卖家，可以为空。 |
| `store_id`     | Integer  | 外键，关联到 `item` 表中的 `ItemId`，标识该订单包含的商品。  |
| `amount`       | Float    | 订单总金额。                                                 |
| `order_time`   | DateTime | 订单生成时间，默认值为当前时间。                             |
| `details`      | String   | 订单详情，最大长度 255 字符。                                |

**功能描述：**

- `order` 表记录订单信息，包括订单编号、金额、买卖双方、商品详情等。
- 支持记录多种交易形式，例如买家直接购买或卖家发货等。

------

#### 4. `shop_user` 表

| 字段名           | 类型     | 描述                                        |
| ---------------- | -------- | ------------------------------------------- |
| `UserId`         | Integer  | 主键，唯一标识用户。                        |
| `nickname`       | String   | 用户昵称，最大长度 24 字符，不允许为空。    |
| `email`          | String   | 用户邮箱，最大长度 50 字符，唯一约束。      |
| `_password`      | String   | 哈希存储的用户密码，不允许为空。            |
| `isAdmin`        | Boolean  | 是否为管理员用户，默认为 `False`。          |
| `_captcha`       | String   | 哈希存储的验证码，可用于登录或操作验证。    |
| `bank_user_id`   | Integer  | 银行用户 ID，允许为空，表示绑定的银行账户。 |
| `captcha_expiry` | DateTime | 验证码过期时间。                            |
| `is_active`      | Boolean  | 用户是否已激活，默认为 `False`。            |

**功能描述：**

- `shop_user` 表存储商城用户信息，包括基本信息（如昵称、邮箱）和权限信息（是否为管理员）。
- 支持绑定银行账户和验证码验证功能，提供用户身份验证和操作安全性。

#### API接口描述

#### 用户认证模块

## 1. 用户注册（/register）

```mermaid
sequenceDiagram
    participant 用户
    participant Web
    participant 数据库

    用户->>Web: 提交注册表单（nickname, email, password）
    Web->>数据库: 查询是否已有该email注册
    alt 用户已注册
        Web->>用户: 返回"该邮箱已被注册"
    else 用户未注册
        Web->>数据库: 插入新用户数据
        Web->>数据库: 生成验证码并保存
        Web->>用户: 返回"注册成功，请检查您的邮箱以激活账号"
    end
```

### 接口描述：

- **功能**：用户通过提交昵称、邮箱和密码进行注册。系统会检查该邮箱是否已经注册过，如果注册过则返回错误提示；如果没有注册，则创建新的用户并生成激活验证码，发送邮件。

- 流程

  ：

  1. 用户提交注册表单。
  2. 系统检查邮箱是否已注册。
  3. 如果邮箱已注册，返回错误提示。
  4. 如果未注册，插入用户数据并生成验证码。
  5. 发送激活邮件，提示用户激活账户。

------

## 2. 用户激活（/activate）

```mermaid
sequenceDiagram
    participant 用户
    participant Web
    participant 数据库

    用户->>Web: 提交激活表单（email, code）
    Web->>数据库: 查询用户是否存在
    alt 用户不存在
        Web->>用户: 返回"用户不存在"
    else 用户存在
        Web->>数据库: 验证验证码是否有效
        alt 验证成功
            Web->>数据库: 更新用户状态为激活
            Web->>用户: 返回"账户激活成功，请登录"
        else 验证失败
            Web->>用户: 返回"验证码错误或已过期"
        end
    end
```

### 接口描述：

- **功能**：用户通过提交邮箱和验证码激活账户，验证验证码是否有效，成功后将账户状态设置为激活。

- 流程

  ：

  1. 用户提交邮箱和验证码。
  2. 系统查询用户是否存在。
  3. 如果用户不存在，返回错误信息。
  4. 如果用户存在，验证验证码的正确性。
  5. 如果验证码正确，更新用户为已激活状态，并提示登录；否则返回错误。

------

## 3. 用户登录（/login）

```mermaid
sequenceDiagram
    participant 用户
    participant Web
    participant 数据库

    用户->>Web: 提交登录表单（email, password）
    Web->>数据库: 查询邮箱是否存在
    alt 用户不存在
        Web->>用户: 返回"用户不存在"
    else 用户存在
        Web->>数据库: 验证密码是否正确
        alt 密码正确
            Web->>数据库: 登录用户
            Web->>用户: 返回"登录成功"
        else 密码错误
            Web->>用户: 返回"密码错误"
        end
    end
```

### 接口描述：

- **功能**：用户通过邮箱和密码登录系统，系统验证用户是否存在且密码是否正确，成功则登录并返回成功信息。

- 流程

  ：

  1. 用户提交邮箱和密码。
  2. 系统查询邮箱是否已注册。
  3. 如果邮箱未注册，返回错误信息。
  4. 如果邮箱已注册，验证密码是否正确。
  5. 密码正确则登录用户并返回成功，密码错误则提示错误。

------

## 4. 用户登出（/logout）

```mermaid
sequenceDiagram
    participant 用户
    participant Web

    用户->>Web: 请求登出
    Web->>Web: 执行登出操作
    Web->>用户: 返回"您已成功退出登录"
```

### 接口描述：

- **功能**：用户点击登出按钮后，系统会将用户登出，并返回登出成功信息。

- 流程

  ：

  1. 用户发起登出请求。
  2. 系统执行登出操作。
  3. 系统返回登出成功信息。

------

## 5. 绑定银行卡（/bind_bank_card）

```mermaid
sequenceDiagram
    participant 用户
    participant Web
    participant 银行

    用户->>Web: 请求绑定银行卡
    Web->>银行: 重定向到银行授权页面
    银行->>Web: 用户授权后返回授权码
    Web->>银行: 使用授权码获取访问令牌
    银行->>Web: 返回访问令牌
    Web->>银行: 使用访问令牌获取用户信息
    银行->>Web: 返回用户银行卡信息
    Web->>用户: 返回银行卡绑定成功或选择银行卡
```

### 接口描述：

- **功能**：用户在商城中进行银行卡绑定操作，系统重定向用户到银行授权页面，用户完成授权后，系统使用授权码获取访问令牌并获取银行卡信息。

- 流程

  ：

  1. 用户发起绑定银行卡请求。
  2. 系统将用户重定向到银行授权页面。
  3. 银行返回授权码，系统使用授权码获取访问令牌。
  4. 系统用访问令牌获取银行卡信息。
  5. 如果用户有多张银行卡，提示用户选择；如果只有一张，则直接绑定。

#### shop核心业务逻辑

### 1. 首页显示商品列表

#### 接口功能

- **接口描述**：显示所有商品的信息。
- **请求方式**：GET
- **请求路径**：`/shop`
- **请求参数**：无
- **返回数据**：商品列表

```mermaid
sequenceDiagram
    participant 客户端
    participant 服务端

    客户端->>服务端: GET /shop
    服务端->>数据库: 查询所有商品数据
    服务端->>客户端: 返回商品列表页面
```

### 2. 查看商品详情

#### 接口功能

- **接口描述**：展示单个商品的详细信息。
- **请求方式**：GET
- **请求路径**：`/shop/item/<int:item_id>`
- **请求参数**：商品ID
- **返回数据**：商品详情页面

```mermaid
sequenceDiagram
    participant 客户端
    participant 服务端
    participant 数据库

    客户端->>服务端: GET /shop/item/<item_id>
    服务端->>数据库: 根据 item_id 查询商品
    服务端->>客户端: 返回商品详情页面
```

### 3. 上传商品

#### 接口功能

- **接口描述**：卖家上传商品。

- **请求方式**：POST

- **请求路径**：`/shop/upload_item`

- 请求参数

  ：

  - 商品名称、类型、价格、描述、图片

- **返回数据**：上传成功或失败的消息

```mermaid
sequenceDiagram
    participant 客户端
    participant 服务端
    participant 数据库

    客户端->>服务端: POST /shop/upload_item
    服务端->>服务端: 验证用户是否绑定银行账户
    服务端->>数据库: 将商品信息保存到数据库
    服务端->>客户端: 返回商品上传成功消息
```

### 4. 购物车

#### 接口功能

- **接口描述**：显示用户购物车中的商品。
- **请求方式**：GET
- **请求路径**：`/shop/cart`
- **请求参数**：无
- **返回数据**：购物车商品列表页面

```mermaid
sequenceDiagram
    participant 客户端
    participant 服务端
    participant 数据库

    客户端->>服务端: GET /shop/cart
    服务端->>数据库: 查询用户的购物车数据
    服务端->>客户端: 返回购物车商品列表页面
```

### 5. 添加商品到购物车

#### 接口功能

- **接口描述**：将商品加入购物车。

- **请求方式**：POST

- **请求路径**：`/shop/add_to_cart/<int:item_id>`

- 请求参数

  ：

  - 商品ID

- **返回数据**：成功消息或错误消息

```mermaid
sequenceDiagram
    participant 客户端
    participant 服务端
    participant 数据库

    客户端->>服务端: POST /shop/add_to_cart/<item_id>
    服务端->>数据库: 查询购物车中是否已有该商品
    alt 如果商品已存在
        服务端->>数据库: 更新商品数量
    else 如果商品不存在
        服务端->>数据库: 新增商品到购物车
    end
    服务端->>客户端: 返回已加入购物车的消息
```

### 6. 结账

#### 接口功能

- **接口描述**：进行结账操作，生成订单并支付。
- **请求方式**：POST
- **请求路径**：`/shop/checkout`
- **请求参数**：无（会根据购物车中的商品生成订单）
- **返回数据**：支付请求成功或失败的消息

```mermaid
sequenceDiagram
    participant 客户端
    participant 服务端
    participant 数据库
    participant 银行

    客户端->>服务端: GET /shop/checkout
    服务端->>数据库: 查询购物车数据
    alt 如果购物车为空
        服务端->>客户端: 返回错误消息（购物车为空）
    else 如果购物车有商品
        服务端->>数据库: 计算总金额并生成订单
        服务端->>银行: 创建支付请求
        银行->>服务端: 返回支付信息
        服务端->>客户端: 重定向到银行支付页面
    end
```

### 7. 支付订单

#### 接口功能

- **接口描述**：支付指定订单。
- **请求方式**：POST
- **请求路径**：`/shop/order/<int:order_id>/pay`
- **请求参数**：订单ID
- **返回数据**：支付成功或失败消息

```mermaid
sequenceDiagram
    participant 客户端
    participant 服务端
    participant 银行

    客户端->>服务端: POST /shop/order/<order_id>/pay
    服务端->>银行: 发起支付请求
    银行->>服务端: 返回支付结果
    alt 支付成功
        服务端->>客户端: 返回支付成功消息
    else 支付失败
        服务端->>客户端: 返回支付失败消息
    end
```

### 8. 上传商品图片

#### 接口功能

- **接口描述**：上传商品图片。
- **请求方式**：POST
- **请求路径**：`/shop/upload_item_image`
- **请求参数**：商品图片
- **返回数据**：上传成功或失败消息

```mermaid
sequenceDiagram
    participant 客户端
    participant 服务端

    客户端->>服务端: POST /shop/upload_item_image
    服务端->>服务端: 保存上传的图片
    服务端->>客户端: 返回图片上传成功消息
```

### 9. 用户个人信息

#### 接口功能

- **接口描述**：显示用户的基本信息和银行账户绑定状态。
- **请求方式**：GET
- **请求路径**：`/shop/profile`
- **请求参数**：无
- **返回数据**：用户个人信息页面

```mermaid
sequenceDiagram
    participant 客户端
    participant 服务端

    客户端->>服务端: GET /shop/profile
    服务端->>服务端: 查询用户的银行账户信息
    服务端->>客户端: 返回用户信息和银行账户绑定状态
```

### 10. 选择银行账户

#### 接口功能

- **接口描述**：用户选择绑定的银行卡。
- **请求方式**：POST
- **请求路径**：`/shop/select_bank_card`
- **请求参数**：银行卡ID
- **返回数据**：银行卡绑定成功消息或错误消息

```mermaid
sequenceDiagram
    participant 客户端
    participant 服务端

    客户端->>服务端: POST /shop/select_bank_card
    服务端->>服务端: 绑定用户选择的银行卡
    服务端->>客户端: 返回银行卡绑定成功消息
```

这些接口涵盖了商城模块的主要功能，包括商品浏览、购物车管理、订单处理、支付和账户绑定等操作。

#### 前端界面设计

首先会将用户引导到商城主界面，如果用户没有登录，则购物车等所有功能都会引导到登录界面

![image-20241203161537293](./images/image-20241203161537293.png)

用户的登录与注册界面复用银行登录界面样式

![image-20241203161556237](./images/image-20241203161556237.png)

详情界面

![image-20241203161608184](./images/image-20241203161608184.png)

上传商品界面

![image-20241203161628092](./images/image-20241203161628092.png)

购物车界面

![image-20241203161646659](./images/image-20241203161646659.png)

支付界面

![image-20241203165327906](./images/image-20241203165327906.png)

确认支付界面

![image-20241203165353747](./images/image-20241203165353747.png)

### 银行、证书机构、商城三者数据联动

#### 证书验证与证书申请

 我们实现CA证书机构后，可以保证HTTPS和ssl协议的正常运作。首先启动CA证书机构后，CA会对自己的证书进行签名，再启动银行和商城时，首先会验证CA的证书，确保CA可信，当验证通过后，Bank和Shop会分别各自以`bank_application`和`shop_application`来向CA机构申请自己的证书，CA机构向他们颁发证书，bank和shop将自己获得的证书保存到自己的特定目录下。以后每次启动的时候，会首先向CA机构验证自己获得的证书是否有效，有效通过证书的过期时间和是否被手动吊销来判断，如果证书有效，则正常启动，否则会重新调用申请证书的接口来申请证书。



```mermaid
sequenceDiagram
    participant CA证书机构
    participant Bank
    participant Shop
    participant 客户端

    %% 启动 CA证书机构并签发自身证书
    CA证书机构->>CA证书机构: 启动 CA 证书机构
    CA证书机构->>CA证书机构: 对自己的证书进行签名

    %% 启动 Bank，并验证 CA 证书
    Bank->>CA证书机构: 请求验证 CA 证书
    CA证书机构->>Bank: 返回 CA 证书验证结果（CA可信）

    %% Bank 向 CA 证书机构申请证书
    Bank->>CA证书机构: 提交申请，申请 bank_application 证书
    CA证书机构->>Bank: 颁发 bank_application 证书
    Bank->>Bank: 保存 bank_application 证书到指定目录

    %% 启动 Shop，并验证 CA 证书
    Shop->>CA证书机构: 请求验证 CA 证书
    CA证书机构->>Shop: 返回 CA 证书验证结果（CA可信）

    %% Shop 向 CA 证书机构申请证书
    Shop->>CA证书机构: 提交申请，申请 shop_application 证书
    CA证书机构->>Shop: 颁发 shop_application 证书
    Shop->>Shop: 保存 shop_application 证书到指定目录

    %% 启动 Bank，每次启动前验证证书
    Bank->>CA证书机构: 向 CA 申请验证 bank_application 证书
    CA证书机构->>Bank: 验证 bank_application 证书是否有效（检查过期时间、吊销状态）
    alt 证书有效
        CA证书机构->>Bank: 证书有效，启动 Bank
    else 证书无效
        CA证书机构->>Bank: 证书无效，重新申请证书
        Bank->>CA证书机构: 重新申请证书
        CA证书机构->>Bank: 颁发新的证书
    end

    %% 启动 Shop，每次启动前验证证书
    Shop->>CA证书机构: 向 CA 申请验证 shop_application 证书
    CA证书机构->>Shop: 验证 shop_application 证书是否有效（检查过期时间、吊销状态）
    alt 证书有效
        CA证书机构->>Shop: 证书有效，启动 Shop
    else 证书无效
        CA证书机构->>Shop: 证书无效，重新申请证书
        Shop->>CA证书机构: 重新申请证书
        CA证书机构->>Shop: 颁发新的证书
    end

```

当银行和商城之间需要通信时，需要先向CA机构认证对方的证书是否有效，若有效，则建立TLS信道进行信息通信，若无效，则报错对方证书认证失败，此时对方不可信，为了保证安全性，程序应当终止信息通信。

```mermaid
sequenceDiagram
    participant CA证书机构
    participant Bank
    participant Shop

    %% 银行和商城之间的通信
    Bank->>CA证书机构: 向CA验证商城证书（shop_application）
    CA证书机构->>Bank: 返回商城证书验证结果（有效或无效）
    
    alt 商城证书有效
        CA证书机构->>Bank: 证书有效，建立TLS信道
        Bank->>Shop: 请求建立安全连接（通过TLS信道）
        Shop->>Bank: 响应建立安全连接（确认TLS信道）
        Bank->>Shop: 发送数据（通过TLS加密信道）
        Shop->>Bank: 接收数据（通过TLS解密信道）
    else 商城证书无效
        CA证书机构->>Bank: 证书无效，报错
        Bank->>Bank: 终止信息通信（商城证书不可信）
    end

    %% 同样的流程反向进行：商城向银行验证银行证书
    Shop->>CA证书机构: 向CA验证银行证书（bank_application）
    CA证书机构->>Shop: 返回银行证书验证结果（有效或无效）
    
    alt 银行证书有效
        CA证书机构->>Shop: 证书有效，建立TLS信道
        Shop->>Bank: 请求建立安全连接（通过TLS信道）
        Bank->>Shop: 响应建立安全连接（确认TLS信道）
        Shop->>Bank: 发送数据（通过TLS加密信道）
        Bank->>Shop: 接收数据（通过TLS解密信道）
    else 银行证书无效
        CA证书机构->>Shop: 证书无效，报错
        Shop->>Shop: 终止信息通信（银行证书不可信）
    end

```

#### 商城绑定银行账号的Oauth

这一模块是我设计的最满意的部分，实现了一个完整的Oauth2.0流程，并做到了交互的优雅、简洁、可用。

为了简便，下面的情况都是shop和bank双方在进行了可信协商之后建立的加密信道通信的情况。

Oauth的过程如下：

**商城请求授权：**
商城发起请求，跳转到银行的授权页面，携带`client_id`、`redirect_uri`、`scope`、`state`。

**银行授权：**
用户在银行页面同意授权，银行生成授权码，并重定向回商城的`redirect_uri`。

**商城获取令牌：**
商城使用授权码向银行请求访问令牌（`access_token`），传递`client_id`、`client_secret`、`code`等参数。

**银行发放令牌：**
银行验证请求，返回`access_token`。

**商城获取用户信息：**
商城使用访问令牌向银行请求用户信息（如银行卡信息）。

**银行返回用户信息：**
银行验证令牌有效性后，返回用户信息。

**银行卡绑定：**
商城根据返回的银行卡信息执行绑定。

```mermaid
sequenceDiagram
    participant Shop
    participant Bank

    Shop->>Bank: 请求授权 (client_id, redirect_uri, scope, state)
    Bank->>Shop: 授权页面 (展示给用户)
    Shop->>Bank: 用户同意授权，银行生成授权码
    Bank->>Shop: 重定向回商城，附带授权码(code)
    Shop->>Bank: 商城用授权码请求令牌 (client_id, client_secret, code)
    Bank->>Shop: 返回访问令牌 (access_token)
    Shop->>Bank: 商城用令牌获取用户信息 (Authorization: Bearer token)
    Bank->>Shop: 返回用户信息 (user_id, bank_cards)
    Shop->>Shop: 绑定银行卡，更新用户信息

```

其中授权码使用uuid，来保证每一个shop的clientid独一无二且不可以被预测

![image-20241203163125046](./images/image-20241203163125046.png)

#### shop向商城发起支付请求

**购物车结算（`/checkout`）**

- 商城检查购物车是否为空，并验证用户是否已绑定银行账户。
- 计算每个卖家的支付金额，并为每个卖家创建订单。
- 商城将支付数据（买方银行账户、卖方支付金额、总金额和订单ID）发送至银行的`create_payment`接口，要求银行创建支付会话。

**银行创建支付会话（`/create_payment`）**

- 银行接收到支付请求后，生成一个唯一的支付ID，保存支付数据（买方银行账户、卖方支付金额、总金额、订单ID等）到数据库或缓存中。
- 银行返回支付ID，商城将支付ID传递给用户，用户将被重定向到银行支付页面。

**支付页面选择银行卡（`/pay`）**

- 用户访问银行支付页面，银行展示用户的银行卡并要求选择支付卡。
- 用户选择支付卡后，银行会发送验证码至用户邮箱。
- 用户输入验证码并确认银行卡后，银行进入支付确认环节。

**支付确认（`/confirm_payment`）**

- 用户输入支付密码和验证码后，银行验证密码和验证码。
- 银行检查用户选择的银行卡余额是否足够支付总金额。
- 如果余额足够，银行通过转账操作将资金从买方银行卡转到各个卖方银行卡。
- 每笔转账记录都会生成一个交易记录，并返回支付成功的消息。

**订单支付完成**

- 商城和银行将支付状态更新为“成功”，并展示支付成功的界面。
- 支付完成后，商城的订单状态更新，用户可以查看订单详情。

```mermaid
sequenceDiagram
    participant Shop
    participant Bank
    participant User

    Shop->>Bank: 发送支付请求 (buyer_bank_user_id, seller_payments, total_amount, order_ids)
    Bank->>Shop: 返回支付ID
    Shop->>User: 重定向到支付页面，附带支付ID
    User->>Bank: 选择支付卡，发送验证码请求
    Bank->>User: 发送验证码到用户邮箱
    User->>Bank: 输入支付密码和验证码
    Bank->>User: 验证支付密码和验证码
    Bank->>Bank: 检查余额是否足够
    Bank->>Bank: 执行转账操作
    Bank->>Shop: 返回支付成功信息
    Shop->>User: 显示支付成功页面
    Bank->>User: 提供交易详情

```

# 5.实现与测试

大部分实现已经在前文中展示出来，下面的重点在于实现的结果和一些我认为比较有价值的代码。

## 4.1后端的实现

整体项目结构如下

![image-20241203163657174](./images/image-20241203163657174.png)

以bank为例，在app下存放着flask服务端的主题，通过运行`run.py`进行启动

将一些保密配置放置在`secure.py`下，常见的配置放在`settings.py`下。`models`中存放着orm模型，用于与数据库交互。

### 部署架构

项目在设计shop的时候考虑到了后续的`秒杀`等活动带来的高频词访问的情况，这个情况会产生大量数据库查询，因此为了避免脆弱的mysql挂掉，在查询的前一层放置了redis来实现对消息队列的管理，以及对mysql的部分商品信息`<id:商品类>` 这种键值对的管理。

![image-20241203170051947](./images/image-20241203170051947.png)

### SQLAlchemy基类的简单改写

我们知道，当我们实例了一个db对象后，并将他注册到flask的blueprint下，需要用`try...catch`的结构来向数据库提交数据，当提交错误时，需要调用`db.session.rollback()`，代码中有大量的操作数据库的代码，如果都这么写将会使代码可读性不可容忍地降低，因此有必要重新改写基类。利用python的上下文特性

```python
@contextmanager
    def auto_commit(self):
        try:
            yield
            self.session.commit()
        except Exception as e:
            self.session.rollback()
            # 正常抛出sqlalchemy的异常
            raise e
```

同时为了增加后续对数据库分析的便捷，会自动保存上传数据的时间这一字段

```python
@property
    def create_datetime(self):
        if self.create_time:
            return datetime.fromtimestamp(self.create_time)
        else:
            return None
```

以后别的Models只需要继承这个我自己改写的基类即可。

#### CA机构的证书管理类

CA机构的核心逻辑被封装在CA_manager下，使用x509证书格式

**加载CA证书和私钥（`load_ca`函数）**： 该函数从文件系统中加载CA（证书颁发机构）证书和私钥，用于后续的证书签发。私钥和证书以PEM格式存储，私钥用于对证书进行签名。

**签发用户证书（`issue_certificate`函数）**： 该函数接收一个`common_name`（即用户的证书公共名称）作为输入，通过生成一个新的RSA密钥对来创建用户的公钥。然后，它构建一个新的证书，包括：

- 证书的主体（用户的`common_name`）。
- 证书的颁发者（即加载的CA证书的主体）。
- 证书的公钥（由用户的RSA密钥对提供）。
- 证书的有效期（从当前时间起，1年有效）。
- 证书的序列号（随机生成）。
- 证书的签名（使用CA的私钥对证书进行签名）。

然后，这个证书会被保存到数据库中，并且返回证书的PEM格式和私钥的PEM格式。

**吊销证书（`revoke_certificate`函数）**： 该函数接收一个`common_name`，从数据库中查找该`common_name`对应的证书，并将其标记为已吊销（`revoked = True`）。如果找到未吊销的证书，更新状态并提交到数据库。如果没有找到证书或已经吊销的证书，则返回`False`。

**检查证书是否被吊销（`is_certificate_revoked`函数）**： 该函数用于检查给定`common_name`的证书是否被吊销。它会从数据库中查找所有与`common_name`匹配的证书，按颁发日期降序排序，并检查是否有未吊销且未过期的证书。如果找到有效证书，则返回`False`（未吊销）；如果没有有效证书，则返回`True`（已吊销或无效）。

![image-20241203164418104](./images/image-20241203164418104.png)

![image-20241203165000046](./images/image-20241203165000046.png)

#### 装饰器

在项目中，采用了大量python的装饰器语法，例如flask自己的路由`@shop_bp.route('/upload_item_image', methods=['POST'])`，以及身份验证`@jwt_required`，还有我自己实现的验证证书可信的装饰器。

例如当shop向银行发起支付请求时，首先利用装饰器`verify_bank_certificate`向CA机构发起验证bank证书的请求，通过将这个方法封装为装饰器，以后在二者需要相互通信的api函数前放置装饰器就可以完成。

```mermaid
sequenceDiagram
    participant F as 被装饰函数
    participant S as 装饰器
    participant Bank as 银行服务器
    participant CA as CA服务
    participant FS as 文件系统

    S->>S: 创建未验证的SSL上下文
    S->>Bank: 与银行服务器建立连接并获取证书
    Bank->>S: 返回DER格式证书
    S->>S: 将DER格式证书转换为PEM格式
    S->>S: 解析PEM证书并提取Common Name
    S->>CA: 请求验证证书是否被吊销
    CA->>S: 返回证书验证结果
    alt 证书未被吊销
        S->>S: 设置验证状态并记录日志
    else 证书被吊销
        S->>S: 记录日志并返回403错误
        S->>F: 结束流程
    end
    S->>FS: 保存证书到本地文件系统
    FS->>S: 返回保存结果
    S->>F: 传递证书路径并调用被装饰函数
    F->>F: 执行被装饰函数
    F->>S: 结束

```

此外，为了减少前端代码的臃肿，我使用了`WTForms`这个库来对表单进行管理，通过一个个class的定义来实现对表单的筛选和处理。

![image-20241203164904127](./images/image-20241203164904127.png)

### 安全测试

首先应该宏观配置flask-limiters来限制ip对接口的访问频率。

#### 流量分析

由于我们采用CA机构确保可信，因此在tls、ssl协议的保证下，流量捕包将没有任何实质作用。

![image-20241203165610952](./images/image-20241203165610952.png)

可以看到，整个过程都是tls协议，内容都是密文，因此无法被直接分析。使用tls协议可以有效避免中间人攻击和任何流量分析

#### SQL注入

项目大部分使用 `RestFul API`格式，例如`https://127.0.0.1:8888/shop/item/2`，则sqlmap无法自动化注入，但可以尝试注入带有参数的url，例如`https://127.0.0.1:5000/bank/pay?payment_id=d58f53b1-67e5-41dc-af8f-2e478bceac89`

首先第一关就被拦了，因为我配置了`flask-limiter`，限制一个ip一分钟只能访问60次 ,`429`就是`Too Many Requests`

![image-20241203171455257](./images/image-20241203171455257.png)

![image-20241203171601229](./images/image-20241203171601229.png)

当手动放慢测试速率时，最后回显也是不可注入

#### 文件上传测试

首先部署项目的时候就应该对配置文件有白名单，例如apache服务器的.htaccess就不应该被上传。本项目只有一个上传商品的接口存在文件上传。

首先编写一个简单的执行系统命令的python脚本

```python
import os
os.system('ls;')
```

然后就会被白名单拦住

```python
# 允许的文件类型
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}
```

![image-20241203171233212](./images/image-20241203171233212.png)

#### 针对订单的重放攻击

首先项目实现了完整的2fa流程，即使能重放订单，则也会落实到用户手里来通过输入验证码来完成订单的支付。当然我们本身也应该防住重放攻击。

例如我们先创建了一个订单，`783bf314-6cef-43a0-aae4-53d88b2ea609` 然后完成支付

然后再发送一遍

![image-20241203172017117](./images/image-20241203172017117.png)

因此重放攻击无效。

#### flask-unsign与ssrf

项目为了保证安全性，加入了`jwt_token`和`ssrf_token`，且使用强秘钥进行加密，我使用简单的`flask-unsign`这个库来进行测试

例如对于银行的`jwt_token`

```bash
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTczMzIxMzAyMiwianRpIjoiYjI4MzA5MGUtZmMxMi00MDkzLTgwYzEtZGRlMmUzMjkwYjFmIiwidHlwZSI6ImFjY2VzcyIsInN1YiI6MSwibmJmIjoxNzMzMjEzMDIyLCJleHAiOjE3MzMyOTk0MjIsInVzZXJfdHlwZSI6ImJhbmsifQ.XV7d1EuICmKFBwO2Xe2iFalZwoD9ZsLZPlpzVaqTxIQ
```

![image-20241203172836794](./images/image-20241203172836794.png)

![image-20241203173005144](./images/image-20241203173005144.png)

# 6.总结

通过这个项目，我更加熟练掌握了python-web的`flask`全套技术栈，同时深入理解了`tls1.2`协议和`Oauth`的工作原理。应当吸取的经验是在项目开发前，应当做好详细的需求分析等系统建设，否则后续每次更改数据库表，以及添加功能时，由于模块耦合度较高，工作量极大，十分痛苦。另外，小组合作也是项目的关键，本人很遗憾，由于队友过于摆烂，在10月左右的时候就已经上传了项目仓库，希望一起合作开发，但后续一个人几乎联系不上，一个人乱弹琴。但项目截止日期日渐迫近，我总归要得到及格的成绩，遂放弃了最初的flask-vue的前后端分离的常见架构，转为使用flask-jinjia的模式，这样效率很高。项目由本人一个人开发，尽管难度不大，但在最忙的时候承担所有工作，很难有愉快的心理状态。

对于这种相对常见的CRUD项目，使用Django这种重型框架更能减少重复的工作，同时由于复用了库中提供的函数，也大大提高了安全性。

我技术能力有限，项目开发过程中肯定有很多质量非常差的代码，同时由于web攻击学业不精，仅仅测试了一小部分代码的安全性，但整体项目是简洁、可用和安全的。
